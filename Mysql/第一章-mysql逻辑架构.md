<p style="text-align:center;font-size:28px;font-weight:bold;">Mysql基础架构</p>

1. ##### 逻辑架构

   **连接管理：**每个客户端连接都会在服务器进程中拥有一个线程，这个连接的查询只会在这个单独的线程中执行。

   **优化执行：**对于SELECT 语句，在解析查询之前，服务器会先检查查询缓存 （Query Cache），如果能够在其中找到对应的查询，服务器就不必再执行查询解析、优化和执行的整个过程，而是直接返回查询缓存中的结果集。

2. ##### 并发控制

   **读写锁：**

   * 在处理并发读或者写时，可以通过实现锁系统来解决问题。有两种类型的锁通常被称为共享锁（shared lock）和排他锁 （exclusive lock），也叫读锁（read lock）和写锁（write lock）。

   * 写锁比读锁有更高的优先级，因此一个写锁请求可能会被插入到读锁队列的前面（反之读锁则不能插入到写锁的前面）。

   **锁粒度：**
   加锁也需要消耗资源。锁的各种操作，包括获得锁、检查锁是否已经解除、释放锁等，都会增加系统的开销。如果系统花费大量的时间来管理锁，而不是存取数据，那么系统的性能可能会因此受到影响。

   * 表锁：表锁是MySQL中最基本的锁策略，并且是开销最小的策略。它会锁定整张表。
   * 行级锁：行级锁可以最大程度地支持并发处理（同时也带来了最大的锁开销）。只在存储引擎层实现。

3. ##### 事务
   **概念：**事务就是一组原子性的SQL查询，或者说一个独立的工作单元。如 果数据库引擎能够成功地对数据库应用该组查询的全部语句，那么就执 行该组查询。如果其中有任何一条语句因为崩溃或其他原因无法执行， 那么所有的语句都不会执行。也就是说，**事务内的语句，要么全部执行成功，要么全部执行失败。**
   
   **标准特征ACID:**原子性（atomicity）、一致性（consistency）、隔离性（isolation） 、持久性（durability）。
   
   **隔离级别：**
   
   * **READ UNCOMMITTED（未提交读）：**在READ UNCOMMITTED 级别，事务中的修改，即使没有提交， 对其他事务也都可见。
   * **READ COMMITTED（提交读）：**一个事务从开始直到提交之前，所做的任何修改对其他事 务都是不可见的。
   * **REPEATABLE READ（可重复读）**：该级别保证了在同一个事务中多次读取同样记录的结果是一致的。
   * **SERIALIZABLE（可串行化）**：SERIALIZABLE是最高的隔离级别。SERIALIZABLE 会在读取的每一行数据上都加锁，所以可能导致大量的超时和锁争用的问题。
   
   **死锁：**
   
   死锁是指两个或者多个事务在同一资源上相互占用，并请求锁定对方占用的资源，从而导致恶性循环的现象。
   
   死锁的处理与存储引擎有关。InnoDB目前处理死锁的方法是，**将持有最少行级排他锁的事务进行回滚**（这是相对比较简 单的死锁回滚算法）
   
   **事务日志：**如果数据的修改已经记录到事务日志并持久化，但数据本身还没有 写回磁盘，此时系统崩溃，存储引擎在重启时能够自动恢复这部分修改的数据。
   
4. ##### mysql的事务
   
   * MySQL默认采用**自动提交（AUTOCOMMIT ）模式**。也就是说，如果 不是显式地开始一个事务，则每个查询都被当作一个事务执行提交操作。
   
   * 如果是会导致大量数据改变的操作，比如ALTER TABLE，还有LOCK TABLES 等其他语句会在执行前强制执行提交commit。
   * MySQL**服务器层不管理事务**，事务是由下层的存储引擎实现的。 所以在同一个事务中，使用多种存储引擎是不可靠的。
   * InnoDB采用的是两阶段锁定协议（two-phase locking protocol）。在 事务执行过程中，随时都可以执行锁定，**锁只有在执行COMMIT 或 者ROLLBACK 的时候才会释放**，并且所有的锁是在同一时刻被释放。
   * 除非事务中禁用了AUTOCOMMIT ，可以使用**LOCK TABLES** 之外，其他任何时候都不要显式地执行LOCK TABLES ，不管使用的是什么存储引 擎，否则**会严重影响性能**。
   
5. ##### 多版本并发控制MVCC

   * 可以认为MVCC是行级锁的一个变种，但是它在很多情况下避免了加锁操作，因此开销更低。虽然实现机制有所不同，但大都实现了非阻塞的读操作，写操作也只锁定必要的行。

   * MVCC的实现是通过保存数据在某个时间点的快照来实现的。就是说，不管需要执行多长时间，每个事务看到的数据是一致的。

   * InnoDB的MVCC，是通过在每行记录后面保存两个隐藏的列来实现的。这两个列，一个保存了行的创建时间，一个保存行的过期时间（或 删除时间）。当然存储的并不是实际的时间值，而是系统版本号 （system version number）。每开始一个新的事务，系统版本号都会自动递增。事务开始时刻的系统版本号会作为事务的版本号，用来和查询到的每行记录的版本号进行比较。

6. **mysql的存储引擎**

   **InnoDB**

   * 在文件系统中，MySQL将每个数据库（也可以称之为schema）保存为数据目录下的一个子目录。创建表时，MySQL会在数据库子目录下创建一个和表同名的.frm 文件保存表的定义。

   * InnoDB的数据存储在表空间（tablespace）中，表空间是由InnoDB 管理的一个黑盒子，由一系列的数据文件组成。
   * InnoDB采用MVCC来支持高并发，并且实现了四个标准的隔离级 别。其默认级别是REPEATABLE READ （可重复读），并且通过间隙锁 （next-key locking）策略防止幻读的出现。
   * InnoDB表是基于聚簇索引建立的。
   * InnoDB的索引结构和MySQL的其他存储引擎有很大的不 同，聚簇索引对主键查询有很高的性能。不过它的二级索引（secondary index，非主键索引）中必须包含主键列，所以如果主键列很大的话， 其他的所有索引都会很大。

   **MyISAM**

   * MyISAM不支持事务和行级锁，而且有一个毫无疑问的缺陷就是 崩溃后无法安全恢复。
   * MyISAM对整张表加锁，而不是针对行。读取时会对需要读到的所有表加共享锁，写入时则对表加排他锁。
   * 如果表在创建并导入数据以后，不会再进行修改操作，那么这样的 表或许适合采用MyISAM压缩表。压缩表可以极大地减少磁盘空间占用，因此也可以减少磁盘 I/O，从而提升查询性能。压缩表也支持索引，但索引也是只读的。压缩时表中的记录是独立压缩的，所以读取单行的时候不需要去解压整个表（甚至也不解压行所在的整个页面）。
   * MyISAM最典型的性能问题还是表锁问题，如果你发现所有的查询都长期处于“Locked”状态，那么毫无疑问表锁就是罪魁祸首。